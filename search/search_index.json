{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FasterAPI","text":"<p>As the name suggested, this is a open source project that aims to make FastAPI more easier to use, aka <code>Faster!</code> Although FastAPI is a fantastic framework, it troubles me that it does not include a authentication pipeline. Hence, I created this project which builts a JWT autehntication pipeline as the offcial documentation suggested. Additionally, some important configuration are linked with environment variables &amp; yaml files for convenience.</p> <p>Please feel free to use it as the baseline for your next project!</p> <p>We have been using it as a quick startup for our projects at Innovation Centre Perth. Welcome all visitors!</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install FasterAPI==0.0.32\n</code></pre> <p><code>Note:</code> Latest version is changing to a CLI toolkit which is still under development.</p>"},{"location":"about/","title":"About Me","text":"<p>Hello, I'm <code>Dr Yifei Ren</code>!</p> <p>I am <code>Technology Lead</code> (Technical Project Manager) at Innovation Centre Perth. All welcome to visit us for potential collaborations!</p>"},{"location":"about/#contact-information","title":"Contact Information","text":"<ul> <li>Email: yifei.ren@curtin.edu.au</li> <li>LinkedIn: https://www.linkedin.com/in/yifei-ren-8b021311a/</li> <li>GitHub: https://github.com/ulfaric</li> </ul>"},{"location":"api/","title":"Installation","text":"<pre><code>pip install -U FasterAPI\n</code></pre> <p>All dependencies will be automatically installed, this includes everything from FastAPI. The SQL driver is using <code>psycopg2-binary</code>. </p> <p>To start with default configuration, simply create a python file with the following content:</p> <pre><code>import uvicorn\nfrom FasterAPI.utils import init_migration, create_superuser\n\nif __name__ == \"__main__\":\n    # create a superuser, optional\n    create_superuser(\n        username=\"admin\",\n        password=\"admin\",\n        first_name=\"admin\",\n        last_name=\"admin\",\n        email=\"admin@admin.com\"\n    )\n    # start the fastapi app\n    uvicorn.run(\"FasterAPI.app:app\", host=\"127.0.0.1\", log_level=\"info\", reload=True)\n</code></pre> <p>Now you have a backend with JWT authentication pipeline up and running!</p>"},{"location":"api/endpoints/","title":"Built-in Endpoints","text":"<p>FastAPI automatically generated a endpoints documentation page based on swagger. You can access it via http://IP:PORT/docs, where <code>IP</code> and <code>PORT</code> is defined in your script that starts the server with uvicorn. <code>/docs</code> is the default URL, if you did not set <code>DOCS_URL</code> in your <code>meta_config.yaml</code>.</p>"},{"location":"api/models/active_session/","title":"Active Session","text":"<p>This model is used to store active session for users. It has a one-to-one relationship with <code>User</code> model. If multiple session is not allowed, user has to login again on any new device.</p> <p>             Bases: <code>Base</code></p> <p>Active session model</p> Source code in <code>FasterAPI\\models.py</code> <pre><code>class ActiveSession(Base):\n    \"\"\"Active session model\"\"\" \"\"\n\n    __tablename__ = \"active_sessions\"\n    id: Mapped[int] = mapped_column(primary_key=True, index=True)\n    username: Mapped[str] = mapped_column(\n        ForeignKey(\"users.username\"), index=True, unique=True\n    )\n    client: Mapped[str]\n    exp: Mapped[datetime]\n    user: Mapped[\"User\"] = relationship(\"User\", back_populates=\"session\")\n</code></pre>"},{"location":"api/models/active_session/#FasterAPI.models.ActiveSession.__tablename__","title":"<code>__tablename__ = 'active_sessions'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/active_session/#FasterAPI.models.ActiveSession.client","title":"<code>client: Mapped[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/active_session/#FasterAPI.models.ActiveSession.exp","title":"<code>exp: Mapped[datetime]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/active_session/#FasterAPI.models.ActiveSession.id","title":"<code>id: Mapped[int] = mapped_column(primary_key=True, index=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/active_session/#FasterAPI.models.ActiveSession.user","title":"<code>user: Mapped[User] = relationship('User', back_populates='session')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/active_session/#FasterAPI.models.ActiveSession.username","title":"<code>username: Mapped[str] = mapped_column(ForeignKey('users.username'), index=True, unique=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/blacklisted_token/","title":"Blacklisted Token","text":"<p>This model stores the blacklisted JWT token after user logged out. It will be automatically cleared out at a configurable interval to keep the performance optimised.</p> <p>             Bases: <code>Base</code></p> <p>Blacklisted token model</p> Source code in <code>FasterAPI\\models.py</code> <pre><code>class BlacklistedToken(Base):\n    \"\"\"Blacklisted token model\"\"\" \"\"\n\n    __tablename__ = \"blacklisted_tokens\"\n    id: Mapped[int] = mapped_column(primary_key=True, index=True)\n    token: Mapped[str] = mapped_column(unique=True, index=True)\n    exp: Mapped[datetime]\n</code></pre>"},{"location":"api/models/blacklisted_token/#FasterAPI.models.BlacklistedToken.__tablename__","title":"<code>__tablename__ = 'blacklisted_tokens'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/blacklisted_token/#FasterAPI.models.BlacklistedToken.exp","title":"<code>exp: Mapped[datetime]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/blacklisted_token/#FasterAPI.models.BlacklistedToken.id","title":"<code>id: Mapped[int] = mapped_column(primary_key=True, index=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/blacklisted_token/#FasterAPI.models.BlacklistedToken.token","title":"<code>token: Mapped[str] = mapped_column(unique=True, index=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/user/","title":"User Model","text":"<p>This model is used to store user information.</p> <p>             Bases: <code>Base</code></p> <p>User model</p> Source code in <code>FasterAPI\\models.py</code> <pre><code>class User(Base):\n    \"\"\"User model\"\"\"\n\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True, index=True)\n    username: Mapped[str] = mapped_column(unique=True, index=True)\n    first_name: Mapped[str]\n    last_name: Mapped[str]\n    email: Mapped[str]\n    hashed_password: Mapped[str]\n    is_superuser: Mapped[bool]\n    privileges: Mapped[List[\"UserPrivilege\"]] = relationship(\n        back_populates=\"user\", cascade=\"all,delete\"\n    )\n    session: Mapped[\"ActiveSession\"] = relationship(\n        back_populates=\"user\", cascade=\"all,delete\"\n    )\n</code></pre>"},{"location":"api/models/user/#FasterAPI.models.User.__tablename__","title":"<code>__tablename__ = 'users'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/user/#FasterAPI.models.User.email","title":"<code>email: Mapped[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/user/#FasterAPI.models.User.first_name","title":"<code>first_name: Mapped[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/user/#FasterAPI.models.User.hashed_password","title":"<code>hashed_password: Mapped[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/user/#FasterAPI.models.User.id","title":"<code>id: Mapped[int] = mapped_column(primary_key=True, index=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/user/#FasterAPI.models.User.is_superuser","title":"<code>is_superuser: Mapped[bool]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/user/#FasterAPI.models.User.last_name","title":"<code>last_name: Mapped[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/user/#FasterAPI.models.User.privileges","title":"<code>privileges: Mapped[List[UserPrivilege]] = relationship(back_populates='user', cascade='all,delete')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/user/#FasterAPI.models.User.session","title":"<code>session: Mapped[ActiveSession] = relationship(back_populates='user', cascade='all,delete')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/user/#FasterAPI.models.User.username","title":"<code>username: Mapped[str] = mapped_column(unique=True, index=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/user_privilege/","title":"User Privilege","text":"<p>This model is used to store user privilege/scope. It has a many-to-one relationship with <code>User</code> model.</p> <p>             Bases: <code>Base</code></p> <p>User role model</p> Source code in <code>FasterAPI\\models.py</code> <pre><code>class UserPrivilege(Base):\n    \"\"\"User role model\"\"\"\n\n    __tablename__ = \"user_privileges\"\n    id: Mapped[int] = mapped_column(primary_key=True, index=True)\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    privilege: Mapped[str]\n    user: Mapped[\"User\"] = relationship(\"User\", back_populates=\"privileges\")\n</code></pre>"},{"location":"api/models/user_privilege/#FasterAPI.models.UserPrivilege.__tablename__","title":"<code>__tablename__ = 'user_privileges'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/user_privilege/#FasterAPI.models.UserPrivilege.id","title":"<code>id: Mapped[int] = mapped_column(primary_key=True, index=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/user_privilege/#FasterAPI.models.UserPrivilege.privilege","title":"<code>privilege: Mapped[str]</code>  <code>instance-attribute</code>","text":""},{"location":"api/models/user_privilege/#FasterAPI.models.UserPrivilege.user","title":"<code>user: Mapped[User] = relationship('User', back_populates='privileges')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/models/user_privilege/#FasterAPI.models.UserPrivilege.user_id","title":"<code>user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"guides/background_process/","title":"Background Process","text":"<p>The <code>FastAPI</code> allows you to create the lifespan as a startup background process. However, some timees you may want to add additional background process during run time. To solve this problem, I itergeated the other open source project <code>Akatosh</code>. To add a additional background process, simply user the <code>event</code> decorator with any functions!</p> <p>for exmaple:</p> <pre><code>from Akatosh.event import event\n\n@event(at=Mundus.time, till=inf)\ndef your_function:\n    pass\n</code></pre> <p>Add the above codes inside an endpoint function, then <code>your_function</code> will be run right away till forever! All event interaction supported by Akatosh applies!</p>"},{"location":"guides/configuration/","title":"Configuration","text":"<p>With FasterAPI, you could quickly configure your application via two files: <code>auth_config.yaml</code> and <code>meta_config.yaml</code>. These two files must sit besides your <code>main script</code>, such as the one shown under <code>Getting Started</code>. Otherwise, FasterAPI will use all default configurations. Note that you could also use envrionment variables but they will be overwrittern if configuration file exits.</p>"},{"location":"guides/configuration/#auth_configyaml","title":"auth_config.yaml","text":"<p>Here are all the keys for <code>auth_config.yaml</code>:</p> <pre><code>SQLALCHEMY_DATABASE_URL: 'sqlite:///dev.db' # \"postgresql://&lt;username&gt;:&lt;password&gt;@HOST:PORT/test\"\nSECRET_KEY: # random secret key for JWT creation, you can run openssl rand 32\nALGORITHM: \"HS256\" # hashing algorithm\nTOKEN_URL: \"login\" # url for user login\nTOKEN_EXPIRATION_TIME: 1 # JWT token expiration time in minutes\nALLOW_SELF_REGISTRATION: False # if true, anyone could register a user without autehntication, otherwise only superuser can do so.\n\n# following fields related to COSRF\nALLOW_CREDENTIALS: False\nALLOWED_ORIGINS:\n  - \"*\"\nALLOWED_METHODS:\n  - \"*\"\nALLOWED_HEADERS:\n  - \"*\"\n</code></pre>"},{"location":"guides/configuration/#meta_configyaml","title":"meta_config.yaml","text":"<p>Here are the keys for <code>meta_config.yaml</code>:</p> <pre><code>DEBUG: True\nTITLE: \"My API\"\nDESCRIPTION: \"This is a description of my API\"\nVERSION: \"0.0.2\"\nOPENAPI_URL: \"/openapi.json\"\nDOCS_URL: \"/docs\"\nREDOC_URL: \"/redoc\"\nTERMS_OF_SERVICE: \"\"\nCONTACT: \"\"\nSUMMARY: \"This is a summary of my API\"\nJAEGER_SVC_NAME: \"my-api\" # service name\nJAEGER_TRACE: True # enable tracing\nJAEGER_HOST: \"localhost\" # Jaeger host\nJAEGER_PORT: \"6831\" # Jaeger host port\n</code></pre>"},{"location":"guides/create_model/","title":"Create Model","text":"<p><code>FasterAPI</code> created a <code>Declarative Base</code> instance of SQLAlchemy for you, and all built-in models are linked with this <code>Base</code>. Therefore, your models must be created based on it. Otherwise, the corresponded table will not be created.</p> <p>To do so, follow the below example:</p> <pre><code>from FasterAPI.models import Base\n\nclass MyModel(Base):\n    __tablename__ = \"mymodels\"\n    # attributes\n</code></pre> <p>Upon on starting the server, a lifespan function will create all tables for you.</p>"},{"location":"guides/dependencies/","title":"Dependencies","text":"<p><code>FasterAPI</code> comes with multiple pre-built dependencies for assisting user authentication.</p>"},{"location":"guides/dependencies/#autenticated","title":"autenticated","text":"<p>A dependency function to authenticate the user.</p> Source code in <code>FasterAPI\\dependencies.py</code> <pre><code>async def authenticated(\n    request: Request,\n    security_scopes: SecurityScopes,\n    token: Annotated[str, Depends(oauth2_scheme)],\n    db: Annotated[Session, Depends(get_db)],\n):\n    \"\"\"A dependency function to authenticate the user.\"\"\"\n\n    if security_scopes.scopes:\n        authenticate_value = f'Bearer scope=\"{security_scopes.scope_str}\"'\n    else:\n        authenticate_value = \"Bearer\"\n\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": authenticate_value},\n    )\n    multi_session_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Multiple sessions are not allowed\",\n        headers={\"WWW-Authenticate\": authenticate_value},\n    )\n    scope_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Insufficient privileges\",\n        headers={\"WWW-Authenticate\": authenticate_value},\n    )\n    jwt_exception = HTTPException(\n        status_code=status.HTTP_406_NOT_ACCEPTABLE,\n        detail=\"Invalid JWT token\",\n        headers={\"WWW-Authenticate\": authenticate_value},\n    )\n    jwt_expired_exception = HTTPException(\n        status_code=status.HTTP_406_NOT_ACCEPTABLE,\n        detail=\"JWT token has expired\",\n        headers={\"WWW-Authenticate\": authenticate_value},\n    )\n    blacklisted_token = (\n        db.query(BlacklistedToken).filter(BlacklistedToken.token == token).first()\n    )\n    if blacklisted_token:\n        raise jwt_exception\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload[\"sub\"]\n        expiration = datetime.fromtimestamp(payload[\"exp\"])\n    except JWTError:\n        raise jwt_exception\n    if expiration &lt; datetime.now():\n        raise jwt_expired_exception\n    user = db.query(User).filter(User.username == username).first()\n    if user is None:\n        raise credentials_exception\n    user_privileges = [privilege.privilege for privilege in user.privileges]\n    if not set(security_scopes.scopes).issubset(set(user_privileges)):\n        raise scope_exception\n    active_session = (\n        db.query(ActiveSession).filter(ActiveSession.username == username).first()\n    )\n    if ALLOW_MULTI_SESSIONS is False:\n        if request.client.host != str(active_session.client):  # type: ignore\n            raise multi_session_exception\n    return user\n</code></pre> <p>This dependency can be used on any FastAPI endpoints to secure it that only authenticated user can access. To be authenticated, the user request must contains \"Authorization: Bear XXXX\", where \"XXXX\" is the JWT token obtained after login.</p>"},{"location":"guides/dependencies/#is_superuser","title":"is_superuser","text":"<p>A dependency function to check if the user is a superuser.</p> Source code in <code>FasterAPI\\dependencies.py</code> <pre><code>async def is_superuser(user: Annotated[User, Depends(authenticated)]):\n    \"\"\"A dependency function to check if the user is a superuser.\"\"\"\n    if not user.is_superuser:  # type: ignore\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"The user doesn't have enough privileges\",\n        )\n    return user\n</code></pre> <p>This dependency will secure the endpoint that only authenticated user can access, and the user also must be a superuser.</p>"},{"location":"guides/dependencies/#scope","title":"scope","text":"<p>FasterAPI implemented the Oauth2 scope but it is verified against the user privileges. It means the scopes inside the JWT will always be the user's privileges. Therefore, you can use the scope header to verify against the user privilege. For example:</p> <pre><code>@app.get(\"/users/me/items/\")\nasync def read_own_items(\n    current_user: Annotated[User, Security(authenticated, scopes=[\"items\"])]\n):\n    return [{\"item_id\": \"Foo\", \"owner\": current_user.username}]\n</code></pre> <p>If the user does not have priviledge \"items\", then it will be refused to access endpoint \"/users/me/items/\". Dependency \"is_superuser\" works in the similar manner.</p>"},{"location":"guides/tls/","title":"Setup TLS","text":"<p>Setting up TLS is a painful becuase generating the keys and certificates. Thus, <code>FAsterAPI</code> included utility function to do it for you!</p>"},{"location":"guides/tls/#generate_root_ca","title":"<code>generate_root_ca()</code>","text":"<p>Create a root CA certificate and private key.</p> <p>Parameters:</p> Name Type Description Default <code>expiration_days</code> <code>int</code> <p>the nuber of days before expiration. Defaults to 3650.</p> <code>3650</code> <code>common_name</code> <code>str</code> <p>the common name. Defaults to \"Root CA\".</p> <code>'Root CA'</code> <code>subject_alternative_names</code> <code>Optional[List[str]]</code> <p>the subject alternative names. Defaults to None.</p> <code>None</code> <code>directory</code> <code>Optional[str]</code> <p>the directory to save the files. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[RSAPrivateKey, Certificate]</code> <p>Tuple[rsa.RSAPrivateKey, Certificate]: returns the CA key and certifcate</p> Source code in <code>FasterAPI\\utils.py</code> <pre><code>def generate_root_ca(\n    expiration_days: int = 3650,\n    common_name: str = \"Root CA\",\n    subject_alternative_names: Optional[List[str]] = None,\n    directory: Optional[str] = None,\n) -&gt; Tuple[rsa.RSAPrivateKey, Certificate]:\n    \"\"\"Create a root CA certificate and private key.\n\n    Args:\n        expiration_days (int, optional): the nuber of days before expiration. Defaults to 3650.\n        common_name (str, optional): the common name. Defaults to \"Root CA\".\n        subject_alternative_names (Optional[List[str]], optional): the subject alternative names. Defaults to None.\n        directory (Optional[str], optional): the directory to save the files. Defaults to None.\n\n    Returns:\n        Tuple[rsa.RSAPrivateKey, Certificate]: returns the CA key and certifcate\n    \"\"\"\n\n    key = rsa.generate_private_key(\n        public_exponent=65537, key_size=2048, backend=default_backend()\n    )\n\n    subject = issuer = x509.Name(\n        [\n            x509.NameAttribute(NameOID.COMMON_NAME, common_name),\n        ]\n    )\n\n    builder = x509.CertificateBuilder()\n    builder = builder.subject_name(subject)\n    builder = builder.issuer_name(issuer)\n    builder = builder.public_key(key.public_key())\n    builder = builder.serial_number(x509.random_serial_number())\n    builder = builder.not_valid_before(datetime.now(timezone.utc))\n    builder = builder.not_valid_after(\n        datetime.now(timezone.utc) + timedelta(days=expiration_days)\n    )\n    builder = builder.add_extension(\n        x509.BasicConstraints(ca=True, path_length=None),\n        critical=True,\n    )\n    if subject_alternative_names:\n        san_dns_names = x509.SubjectAlternativeName(\n            [x509.DNSName(name) for name in subject_alternative_names]\n        )\n        builder = builder.add_extension(san_dns_names, critical=False)\n    cert = builder.sign(key, hashes.SHA256(), default_backend())\n\n    if directory:\n        with open(f\"{directory}/root-key.pem\", \"wb\") as f:\n            f.write(\n                key.private_bytes(\n                    encoding=serialization.Encoding.PEM,\n                    format=serialization.PrivateFormat.TraditionalOpenSSL,\n                    encryption_algorithm=serialization.NoEncryption(),\n                )\n            )\n        with open(f\"{directory}/root-cert.pem\", \"wb\") as f:\n            f.write(cert.public_bytes(encoding=serialization.Encoding.PEM))\n\n    return key, cert\n</code></pre> <p>The above function create a root ca (key and certificate). If a directory is given, the generated files will be saved as PEM format. This should be your first step for server certifcate generation.</p>"},{"location":"guides/tls/#generate_key_and_csr","title":"<code>generate_key_and_csr()</code>","text":"<p>Generate a private key and certificate signing request (CSR).</p> <p>Parameters:</p> Name Type Description Default <code>common_name</code> <code>str</code> <p>the common name of the server.</p> required <code>san_dns_names</code> <code>List[str]</code> <p>the subject alternative names of the server.</p> required <code>directory</code> <code>Optional[str]</code> <p>the directory to save the files. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Certificate</code> <code>Tuple[RSAPrivateKey, CertificateSigningRequest]</code> <p>returns the sever private key and certifcate signing request.</p> Source code in <code>FasterAPI\\utils.py</code> <pre><code>def generate_key_and_csr(\n    common_name: str, san_dns_names: List[str], directory: Optional[str] = None\n)-&gt;Tuple[rsa.RSAPrivateKey, CertificateSigningRequest]:\n    \"\"\"Generate a private key and certificate signing request (CSR).\n\n    Args:\n        common_name (str): the common name of the server.\n        san_dns_names (List[str]): the subject alternative names of the server.\n        directory (Optional[str], optional): the directory to save the files. Defaults to None.\n\n    Returns:\n        Certificate: returns the sever private key and certifcate signing request.\n    \"\"\"\n    key = rsa.generate_private_key(\n        public_exponent=65537, key_size=2048, backend=default_backend()\n    )\n\n    subject = x509.Name(\n        [\n            x509.NameAttribute(NameOID.COMMON_NAME, common_name),\n        ]\n    )\n\n    if san_dns_names:\n        extensions = x509.SubjectAlternativeName(\n            [x509.DNSName(name) for name in san_dns_names]\n        )\n\n    csr = (\n        x509.CertificateSigningRequestBuilder()\n        .subject_name(subject)\n        .add_extension(extensions, critical=False)\n        .sign(key, hashes.SHA256(), default_backend())\n    )\n\n    if directory:\n        with open(f\"{directory}/server-key.pem\", \"wb\") as f:\n            f.write(\n                key.private_bytes(\n                    encoding=serialization.Encoding.PEM,\n                    format=serialization.PrivateFormat.TraditionalOpenSSL,\n                    encryption_algorithm=serialization.NoEncryption(),\n                )\n            )\n        with open(f\"{directory}/server-csr.pem\", \"wb\") as f:\n            f.write(csr.public_bytes(encoding=serialization.Encoding.PEM))\n\n    return key, csr\n</code></pre> <p>The above function generate the private key and certificate signing request for your sever. If a directory is given, both files will be saved as PEM format. Note that, the signing request (CSR) is not a certifcate yet. It must be signed by a CA, which can be the one created by step one or your own.</p>"},{"location":"guides/tls/#sign_certificate","title":"<code>sign_certificate()</code>","text":"<p>Sign the certifcate signing request</p> <p>Parameters:</p> Name Type Description Default <code>csr</code> <code>CertificateSigningRequest</code> <p>the certificate signing request.</p> required <code>issuer_key</code> <code>Optional[RSAPrivateKey]</code> <p>the issuer private key.</p> <code>None</code> <code>issuer_key_path</code> <code>Optional[str]</code> <p>the issuer private key path.</p> <code>None</code> <code>issuer_cert</code> <code>Optional[Certificate]</code> <p>the issuer certificate.</p> <code>None</code> <code>issuer_cert_path</code> <code>Optional[str]</code> <p>the issuer certificate path.</p> <code>None</code> <code>validity_days</code> <code>int</code> <p>the number of days before expiration. Defaults to 365.</p> <code>365</code> <code>directory</code> <code>Optional[str]</code> <p>the directory to save the files. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>IssuerKeyNotDefined</code> <p>raise if both issuer_key and issuer_key_path are provided or both ot provided.</p> <code>IssuerCertNotDefined</code> <p>raise if both issuer_cert and issuer_cert_path are provided or both ot provided.</p> <p>Returns:</p> Name Type Description <code>Certificate</code> <code>Certificate</code> <p>returns the signed certificate.</p> Source code in <code>FasterAPI\\utils.py</code> <pre><code>def sign_certificate(\n    csr: CertificateSigningRequest,\n    issuer_key: Optional[rsa.RSAPrivateKey] = None,\n    issuer_key_path: Optional[str] = None,\n    issuer_cert: Optional[Certificate] = None,\n    issuer_cert_path: Optional[str] = None,\n    validity_days=365,\n    directory: Optional[str] = None,\n) -&gt; Certificate:\n    \"\"\"Sign the certifcate signing request\n\n    Args:\n        csr (CertificateSigningRequest): the certificate signing request.\n        issuer_key (Optional[rsa.RSAPrivateKey]): the issuer private key.\n        issuer_key_path (Optional[str]): the issuer private key path.\n        issuer_cert (Optional[Certificate]): the issuer certificate.\n        issuer_cert_path (Optional[str]): the issuer certificate path.\n        validity_days (int, optional): the number of days before expiration. Defaults to 365.\n        directory (Optional[str], optional): the directory to save the files. Defaults to None.\n\n    Raises:\n        IssuerKeyNotDefined: raise if both issuer_key and issuer_key_path are provided or both ot provided.\n        IssuerCertNotDefined: raise if both issuer_cert and issuer_cert_path are provided or both ot provided.\n\n    Returns:\n        Certificate: returns the signed certificate.\n    \"\"\"\n\n    class IssuerKeyNotDefined(Exception):\n        pass\n\n    class IssuerCertNotDefined(Exception):\n        pass\n\n    if issuer_key and issuer_key_path is None:\n        _issuer_key = issuer_key\n    elif issuer_key_path and issuer_key is None:\n        with open(issuer_key_path, \"rb\") as key_file:\n            _issuer_key = serialization.load_pem_private_key(\n                key_file.read(), password=None, backend=default_backend()\n            )\n    else:\n        raise IssuerKeyNotDefined(\"Either issuer_key or issuer_key_path must be provided.\")\n\n    if issuer_cert and issuer_cert_path is None:\n        _issuer_cert = issuer_cert\n    elif issuer_cert_path and issuer_cert is None:\n        with open(issuer_cert_path, \"rb\") as cert_file:\n            _issuer_cert = x509.load_pem_x509_certificate(\n                cert_file.read(), default_backend()\n            )\n    else:\n        raise IssuerCertNotDefined(\"Either issuer_cert or issuer_cert_path must be provided.\")\n\n    cert = (\n        x509.CertificateBuilder()\n        .subject_name(csr.subject)\n        .issuer_name(_issuer_cert.subject)\n        .public_key(csr.public_key())\n        .serial_number(x509.random_serial_number())\n        .not_valid_before(datetime.now(timezone.utc))\n        .not_valid_after(datetime.now(timezone.utc) + timedelta(days=validity_days))\n        .add_extension(\n            x509.BasicConstraints(ca=False, path_length=None),\n            critical=True,\n        )\n        .add_extension(\n            csr.extensions.get_extension_for_class(x509.SubjectAlternativeName).value,\n            critical=False,\n        )\n        .sign(_issuer_key, hashes.SHA256(), default_backend()) # type: ignore\n    )\n\n    if directory:\n        with open(f\"{directory}/server-cert.pem\", \"wb\") as f:\n            f.write(cert.public_bytes(encoding=serialization.Encoding.PEM))\n    return cert\n</code></pre> <p>The above function signs the server certifcate with a CA given by your choice.</p>"},{"location":"guides/tls/#using-tls","title":"Using TLS","text":"<pre><code>uvicorn.run(\n    \"FasterAPI.app:app\",\n    host=\"0.0.0.0\",\n    port=PORT,\n    ssl_certfile=\"path/to/server/certifcate\",\n    ssl_keyfile=\"path/to/server/key\",\n)\n</code></pre>"}]}